---
phase: 11-core-merge-engine
plan: 02
type: tdd
wave: 2
depends_on: ["11-01"]
files_modified:
  - js/core/merge.js
  - test/merge-tests.js
autonomous: true
must_haves:
  truths:
    - "Parent-child quantity of WIP assembly comes from X(n), grafted subtree internal quantities come from B(n-1)"
    - "At graft points, engine compares all fields between X(n) and B(n-1) and stores differences as changes annotation"
    - "Assemblies in B(n-1) but absent from X(n) generate informational warnings listing missing assemblies"
    - "Change annotations are informational only — merge proceeds regardless"
    - "Merged result includes warnings array and summary counts (passed through, grafted, placeholders)"
  artifacts:
    - path: "js/core/merge.js"
      provides: "Complete merge engine with graft boundary rules, change annotations, missing assembly warnings, and merge summary"
      exports: ["isReleased", "buildPNIndex", "mergeBOM"]
    - path: "test/merge-tests.js"
      provides: "Extended tests covering MERGE-07, change annotations, missing assemblies, and merge summary"
      min_lines: 300
  key_links:
    - from: "js/core/merge.js"
      to: "downstream phases (12, 13, 14)"
      via: "mergeBOM return value {mergedTree, warnings, summary}"
      pattern: "return.*mergedTree.*warnings.*summary"
---

<objective>
Extend the merge engine with graft boundary data rules (MERGE-07), change annotations at graft points, missing assembly warnings, and merge summary statistics. This completes all 7 MERGE requirements and all locked decisions from the phase context.

Purpose: The quantity sourcing rules and change annotations are the most architecturally nuanced parts of the merge — getting qty wrong means Operations procures the wrong amounts. Change annotations provide a safety net for Engineering to spot unexpected shifts at graft boundaries.

Output: Updated `js/core/merge.js` with complete merge engine, updated `test/merge-tests.js` with full test coverage.
</objective>

<execution_context>
@C:/Users/amcallister/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/amcallister/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/11-core-merge-engine/11-CONTEXT.md
@.planning/phases/11-core-merge-engine/11-01-SUMMARY.md
@js/core/merge.js
@js/core/tree.js
@test/merge-tests.js
</context>

<tasks>

<task type="auto">
  <name>Task 1: Write failing tests for graft boundary rules, annotations, and warnings (RED)</name>
  <files>test/merge-tests.js</files>
  <action>
Add new test functions to the existing `test/merge-tests.js` file (append after the existing 11 tests).

**New tests:**

12. **Quantity sourcing at graft boundary** (MERGE-07):
    Build tree: GA[IFP] -> A1[IFU] -> A5[Under Revision](qty 3 in X(n))
    Build B(n-1): GA -> A1 -> A5(qty 2) with children C1(3), C2(2)
    Merge. Assert:
    - A5 appears in result under A1 with **qty 3** (from X(n) — the parent A1 is Released, its qty declarations are approved)
    - A5's children are from B(n-1): C1(3), C2(2) — NOT whatever X(n) had
    - A5's metadata (description, revision) comes from **B(n-1)**, not X(n)

13. **Quantity sourcing — root-level WIP** (MERGE-07):
    Build tree: GA[IFP] -> A1[Under Revision](qty 1)
    Build B(n-1): GA -> A1(qty 1) with children C1(5)
    Merge. Assert: A1's qty in result is 1 (from X(n)'s GA declaration), A1's children from B(n-1)

14. **Change annotations at graft point** (locked decision):
    Build tree: GA[IFP] -> A1[IFU] -> A5[WIP](qty 3, description "Assembly Rev B")
    Build B(n-1): GA -> A1 -> A5(qty 2, description "Assembly Rev A") with children
    Merge. Assert:
    - Grafted A5 node has `_changes` property (array or object)
    - `_changes` includes qty difference: "qty: 2 -> 3" (or structured equivalent)
    - `_changes` includes description difference
    - Changes are informational — merge still succeeds

15. **No change annotations when fields match** (locked decision):
    Build tree with WIP assembly having identical fields to B(n-1) version
    Merge. Assert: `_changes` is empty or absent on the grafted node

16. **Missing assembly warning — in B(n-1) but absent from X(n)** (locked decision):
    Build B(n-1): GA -> A1, A2, A3 (all assemblies)
    Build X(n): GA[IFP] -> A1[IFP], A3[IFP] (A2 missing — deleted or suppressed)
    Merge. Assert:
    - warnings include message about A2 being in B(n-1) but absent from X(n)
    - A2 is NOT carried forward into the merged result (warning is informational only)
    - A1 and A3 pass through normally

17. **Missing assembly warning — deep assembly absent** (locked decision):
    Build B(n-1): GA -> A1 -> A5, A6
    Build X(n): GA[IFP] -> A1[IFP] -> A5[IFP] (A6 absent)
    Merge. Assert: warning about A6 missing, A6 not in result

18. **Merge summary statistics** (for downstream UI):
    Build a tree with mix of Released assemblies, grafted WIP assemblies, and one placeholder
    Merge. Assert: return value includes `summary` object with counts:
    - `passedThrough`: number of Released assemblies included from X(n)
    - `grafted`: number of WIP assemblies grafted from B(n-1)
    - `placeholders`: number of WIP assemblies with no prior release (empty placeholders)

19. **Revision mismatch — still grafts** (locked decision):
    Build X(n) with A5[WIP] revision "C"
    Build B(n-1) with A5 revision "A"
    Merge. Assert: A5 is still grafted (no additional warning for rev mismatch — WIP state already signals unapproved content)

Update the test runner to include the new tests and update the pass/fail summary.

Run tests. All new tests (12-19) should FAIL. Existing tests (1-11) should still PASS.
  </action>
  <verify>Run `cd C:/Users/amcallister/Projects/bom-tool/test && node merge-tests.js` — tests 1-11 pass, tests 12-19 fail. This confirms RED phase for the new tests.</verify>
  <done>test/merge-tests.js extended with 8 new tests (12-19) covering MERGE-07, change annotations, missing assembly warnings, merge summary, and revision mismatch handling. New tests fail, existing tests pass.</done>
</task>

<task type="auto">
  <name>Task 2: Implement graft boundary rules, annotations, and warnings (GREEN)</name>
  <files>js/core/merge.js</files>
  <action>
Update `js/core/merge.js` to pass all new tests. Changes needed:

**1. Quantity sourcing at graft boundary (MERGE-07):**

When grafting a WIP assembly, the current implementation deep-clones from B(n-1). The qty on the grafted node needs to come from X(n), not B(n-1). Modify the graft logic:

```
// After cloning the subtree from B(n-1):
graftedNode.qty = sourceNode.qty  // qty from X(n) — parent is Released, its qty declarations are approved
// All OTHER fields on the graft point node (description, revision, state, etc.) stay from B(n-1)
// Children and their quantities stay from B(n-1)
```

This is the key architectural rule: qty belongs to the parent's data (the parent says "I have N of A5"), everything else about the assembly node comes from B(n-1).

**2. Change annotations at graft points:**

After grafting, compare the X(n) node's fields against the B(n-1) node's fields. Store differences:

```
function computeChanges(sourceNode, priorNode):
  changes = []
  if sourceNode.qty !== priorNode.qty:
    changes.push({ field: 'qty', from: priorNode.qty, to: sourceNode.qty })
  if sourceNode.description !== priorNode.description:
    changes.push({ field: 'description', from: priorNode.description, to: sourceNode.description })
  if sourceNode.revision !== priorNode.revision:
    changes.push({ field: 'revision', from: priorNode.revision, to: sourceNode.revision })
  // Compare all meaningful fields: material, state, componentType, partNumber (should match), length, uofm, etc.
  return changes
```

Store as `_changes` property on the grafted node (underscore prefix = ephemeral, same convention as `_source`). Only set if changes array is non-empty.

Per locked decision: annotations are informational. Merge proceeds regardless. No blocking.

**3. Missing assembly warnings:**

After the main merge walk, compare assemblies in B(n-1) against assemblies found in X(n):

```
function findMissingAssemblies(priorRoot, sourceRoot):
  priorAssemblies = collectAllAssemblyPNs(priorRoot)  // Set of PNs
  sourceAssemblies = collectAllAssemblyPNs(sourceRoot)  // Set of PNs
  missing = []
  for pn of priorAssemblies:
    if not sourceAssemblies.has(pn):
      missing.push(pn)
  return missing
```

Add missing assembly warnings to the warnings array:
`"Assembly {PN} exists in B(n-1) but is absent from X(n) — may be deleted or suppressed"`

Per locked decision: do NOT carry forward missing assemblies. Warning is informational only.

**4. Merge summary:**

Track counts during the merge walk and return as `summary`:

```
return {
  mergedTree,
  warnings,
  summary: {
    passedThrough: countReleased,  // Released assemblies included from X(n)
    grafted: countGrafted,         // WIP assemblies grafted from B(n-1)
    placeholders: countPlaceholders  // WIP assemblies with no prior (empty)
  }
}
```

Update the `mergeBOM` function signature: it still takes `(sourceRoot, priorRoot)` and now returns `{ mergedTree, warnings, summary }`. If plan 01 returned `{ mergedTree, warnings }`, add summary to the return. Ensure existing tests still pass (they should — just accessing .mergedTree and .warnings still works, summary is a new field).

After implementation, run ALL tests. All 19 should pass. Also run existing 4 baseline tests.
  </action>
  <verify>
Run `cd C:/Users/amcallister/Projects/bom-tool/test && node merge-tests.js` — all 19 tests pass.
Run `cd C:/Users/amcallister/Projects/bom-tool/test && node run-tests.js` — all 4 existing tests pass (no regressions).
  </verify>
  <done>js/core/merge.js implements complete merge engine: state detection, tree walk, grafting with correct qty sourcing (MERGE-07), change annotations at graft points, missing assembly warnings, and merge summary. All 19 merge tests pass. All 4 existing tests pass. Phase 11 requirements MERGE-01 through MERGE-07 fully implemented, plus all locked decisions from context.</done>
</task>

</tasks>

<verification>
1. `cd C:/Users/amcallister/Projects/bom-tool/test && node merge-tests.js` — 19/19 pass
2. `cd C:/Users/amcallister/Projects/bom-tool/test && node run-tests.js` — 4/4 pass
3. `mergeBOM(sourceRoot, null)` works for REV0 mode — all WIP become placeholders
4. `mergeBOM(sourceRoot, priorRoot)` works for REVn — WIP assemblies grafted from B(n-1)
5. Every node in merged tree has `_source` property
6. Graft point nodes have `_changes` when fields differ between X(n) and B(n-1)
7. Warnings include missing assemblies (in B(n-1) but not X(n))
8. Summary counts match actual merge behavior
9. Qty at graft point comes from X(n), metadata and children from B(n-1)
</verification>

<success_criteria>
- MERGE-07 verified: parent-child qty from X(n), grafted subtree internals from B(n-1)
- Change annotations present at graft points where fields differ
- Missing assembly warnings generated for assemblies in B(n-1) but absent from X(n)
- Missing assemblies NOT carried forward (warning only)
- Merge summary provides counts: passedThrough, grafted, placeholders
- Revision mismatch does not block grafting
- All 19 merge tests pass
- All 4 existing baseline tests pass
- Module API clean for downstream consumption: mergeBOM returns {mergedTree, warnings, summary}
</success_criteria>

<output>
After completion, create `.planning/phases/11-core-merge-engine/11-02-SUMMARY.md`
</output>
