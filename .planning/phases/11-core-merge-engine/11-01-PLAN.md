---
phase: 11-core-merge-engine
plan: 01
type: tdd
wave: 1
depends_on: []
files_modified:
  - js/core/merge.js
  - test/merge-tests.js
autonomous: true
must_haves:
  truths:
    - "isReleased('Issued for Purchasing') returns true, isReleased('Issued for Use') returns true, isReleased('Under Revision') returns false, isReleased('In Design') returns false"
    - "Merge walks tree top-down and stops at first WIP assembly on each branch, grafting entire subtree from B(n-1)"
    - "REV0 mode (no B(n-1)) produces placeholders for all WIP assemblies with warnings"
    - "WIP assembly not found in B(n-1) becomes empty placeholder with warning"
    - "Each branch is evaluated independently — WIP on one branch does not affect other branches"
    - "Deep WIP detection works at L2, L3, and deeper — not just L1"
    - "Every node in merged result carries source tag: current or grafted"
  artifacts:
    - path: "js/core/merge.js"
      provides: "Core merge engine — isReleased, buildPNIndex, mergeBOM"
      exports: ["isReleased", "buildPNIndex", "mergeBOM"]
    - path: "test/merge-tests.js"
      provides: "Automated tests for merge engine covering all MERGE requirements"
      min_lines: 150
  key_links:
    - from: "js/core/merge.js"
      to: "js/core/tree.js"
      via: "imports BOMNode class for node creation"
      pattern: "import.*BOMNode.*from.*tree"
    - from: "test/merge-tests.js"
      to: "js/core/merge.js"
      via: "imports merge functions to test"
      pattern: "import.*from.*merge"
---

<objective>
Build the core IFP merge engine using TDD: state detection whitelist, top-down branch walk with grafting from B(n-1), REV0 mode, empty placeholders for never-released WIP assemblies, multi-branch independence, deep WIP detection, and source tagging on every node.

Purpose: This is the central algorithm for the IFP BOM Merge feature — it determines which branches are approved (Released) and which must be grafted from the prior artifact. Getting this right is critical because Operations relies on the output for procurement.

Output: `js/core/merge.js` module with tested merge algorithm, `test/merge-tests.js` with comprehensive test coverage.
</objective>

<execution_context>
@C:/Users/amcallister/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/amcallister/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/11-core-merge-engine/11-CONTEXT.md
@js/core/tree.js
@js/core/parser.js
@js/core/environment.js
@js/core/utils.js
@test/run-tests.js
</context>

<tasks>

<task type="auto">
  <name>Task 1: Write failing tests for core merge algorithm (RED)</name>
  <files>test/merge-tests.js</files>
  <action>
Create `test/merge-tests.js` as a standalone Node.js test file (same pattern as `test/run-tests.js` — imports modules, runs tests, reports pass/fail, exits with code 0 or 1).

The test file must build BOM trees programmatically using the BOMNode class. Do NOT parse XML files — construct trees directly in code to isolate the merge logic from parsing.

Helper function needed: `makeNode({partNumber, componentType, state, qty, description, revision, children})` that creates a BOMNode from simple params (with sensible defaults for fields not relevant to merge logic like material, length, uofm, etc.). The `children` param is an array of child nodes to attach.

**Tests to write (each as a separate test function):**

1. **State whitelist detection** (MERGE-01):
   - `isReleased` returns true for "Issued for Purchasing" and "Issued for Use"
   - `isReleased` returns false for "Under Revision", "In Design", "", undefined, null, and any other string

2. **Basic graft — L1 WIP assembly** (MERGE-02):
   Build tree: GA[IFP] -> A1[Under Revision] with children C1(3), C2(2)
   Build B(n-1): GA -> A1 with children C1(1), C2(1) (different quantities)
   Merge. Assert: A1's children come from B(n-1) (qty 1, 1), not X(n) (qty 3, 2)
   Assert: A1 node tagged `source: 'grafted'`, GA tagged `source: 'current'`

3. **REV0 mode — no prior artifact** (MERGE-03):
   Build tree: GA[IFP] -> A1[IFU] with children, A2[Under Revision] with children
   Call merge with `priorBOM = null`
   Assert: A1 passes through (Released), A2 becomes empty placeholder (no children)
   Assert: result includes warning about A2 being WIP with no prior release

4. **Empty placeholder for WIP not in B(n-1)** (MERGE-04):
   Build tree: GA[IFP] -> A1[IFP], A2[In Design] (A2 is new)
   Build B(n-1) containing only A1 (no A2)
   Merge. Assert: A2 is present in result as assembly node with zero children
   Assert: warning generated for A2

5. **Multi-branch independence** (MERGE-05):
   Build tree: GA[IFP] -> A1[Under Revision], A2[IFU] -> A6[IFU], A3[IFP], C7
   Build B(n-1) with A1 having different children than X(n)
   Merge. Assert: A1 grafted, A2/A6/A3/C7 all from current. A1's WIP does not affect A2, A3, or C7.

6. **Deep WIP at L2** (MERGE-06):
   Build tree: GA[IFP] -> A1[IFU] -> A5[Under Revision] with children C1(5)
   Build B(n-1): GA -> A1 -> A5 with children C1(3)
   Merge. Assert: A1 from current (released), A5 grafted from B(n-1) (C1 qty 3, not 5)

7. **Deep WIP at L3** (MERGE-06):
   Build tree: GA[IFP] -> A1[IFU] -> A5[IFU] -> A9[Under Revision] with children
   Build B(n-1) with A9 having different children
   Merge. Assert: A1 and A5 from current, A9 grafted from B(n-1)

8. **Source tags on every node** (all):
   Using the multi-branch test, verify EVERY node in the merged tree has either `source: 'current'` or `source: 'grafted'`. Walk the entire result tree and assert no node is missing a source tag.
   Also verify: the WIP assembly node at the graft point is tagged `grafted`, and all children beneath it are also tagged `grafted`.

9. **Same WIP assembly at multiple locations** (from locked decisions):
   Build tree: GA[IFP] -> A1[IFU] -> A5[WIP](qty 2), and also GA -> A5[WIP](qty 1) directly under GA
   Build B(n-1) with A5 having children C1(3)
   Merge. Assert: Both instances of A5 get grafted from B(n-1), each with their own parent's qty from X(n)

10. **All assemblies released — passthrough** (baseline):
    Build tree where every assembly is IFP or IFU
    Merge with B(n-1). Assert: result structurally identical to X(n), all nodes tagged `source: 'current'`

11. **PN-based matching** (locked decision):
    Build B(n-1) where A5 is at a different tree position than in X(n)
    Merge. Assert: A5 is still found and grafted by PN match regardless of position

Run tests with: `cd test && node merge-tests.js`
All tests should FAIL at this point (module doesn't exist yet). Commit after confirming failures.
  </action>
  <verify>Run `cd C:/Users/amcallister/Projects/bom-tool/test && node merge-tests.js` — all tests should fail (import error or assertion failures). This confirms RED phase.</verify>
  <done>test/merge-tests.js exists with 11 test functions covering MERGE-01 through MERGE-06 plus locked decisions, all failing because js/core/merge.js does not yet exist.</done>
</task>

<task type="auto">
  <name>Task 2: Implement merge engine to pass all tests (GREEN)</name>
  <files>js/core/merge.js</files>
  <action>
Create `js/core/merge.js` following the existing module pattern (see tree.js, flatten.js, compare.js for style).

**Exports:**

1. `isReleased(state)` — Returns true if state is exactly "Issued for Purchasing" or "Issued for Use". Everything else returns false (including empty string, undefined, null). Per user decision: whitelist, not blacklist.

2. `buildPNIndex(rootNode)` — Walks a BOM tree and builds a Map of partNumber -> node for O(1) lookup. Used to index B(n-1) for grafting. Only indexes Assembly nodes (componentType === 'Assembly'). If the same PN appears multiple times, store the first occurrence (B(n-1) is a flat truth — same PN has same content everywhere).

3. `mergeBOM(sourceRoot, priorRoot)` — The core algorithm. Returns `{ mergedTree, warnings }`.

   **Algorithm (per PRD pseudocode + locked decisions):**

   ```
   function mergeBOM(sourceRoot, priorRoot):
     priorIndex = priorRoot ? buildPNIndex(priorRoot) : new Map()
     warnings = []

     function walkAndMerge(sourceNode):
       // Check if this assembly is WIP
       if sourceNode.componentType === 'Assembly' AND NOT isReleased(sourceNode.state):
         priorNode = priorIndex.get(sourceNode.partNumber)
         if priorNode:
           // GRAFT: clone entire subtree from B(n-1)
           grafted = deepClone(priorNode)
           // Qty comes from X(n)'s parent (handled by parent — this node's qty is set by parent)
           // Metadata (description, revision, etc.) comes from B(n-1)
           tagSource(grafted, 'grafted')  // tag entire subtree
           return grafted
         else:
           // PLACEHOLDER: WIP with no prior release
           placeholder = createPlaceholder(sourceNode)
           placeholder._source = 'grafted'  // tagged as grafted per decision
           warnings.push(`${sourceNode.partNumber} [${sourceNode.state}] has no prior released BOM — included as empty placeholder`)
           return placeholder

       // RELEASED assembly — include from current, recurse children
       result = shallowCopy(sourceNode)  // metadata from X(n)
       result._source = 'current'
       result.children = sourceNode.children.map(child => {
         if child.componentType === 'Assembly':
           return walkAndMerge(child)
         else:
           childCopy = shallowCopy(child)
           childCopy._source = 'current'
           return childCopy
       })
       return result

     mergedTree = walkAndMerge(sourceRoot)
     return { mergedTree, warnings }
   ```

   **Key implementation details:**

   - **Source tags**: Every node gets `_source` property set to `'current'` or `'grafted'`. Use underscore prefix to signal ephemeral/non-data property. The WIP assembly node at the graft point is tagged `'grafted'` (per locked decision).

   - **Deep clone for grafts**: When grafting from B(n-1), deep clone the entire subtree so the original B(n-1) tree is not mutated. Use a recursive clone function. Tag every cloned node as `'grafted'`.

   - **Shallow copy for current nodes**: Copy all BOMNode properties but create new children array. Do not use `new BOMNode()` — that requires the rowData format. Instead, create a plain object with all the same properties, or use Object.assign + new children array.

   - **Placeholder creation**: Create a node with the WIP assembly's partNumber and componentType='Assembly' from X(n), but empty children array. Mark as `'grafted'` source.

   - **GA root validation**: Per locked decision, only the GA root must be Released. If `sourceRoot` is not Released, the function should still work (return a warning), but this is expected to be caught by the Phase 13 validation system. For now, just process normally — if root is WIP and no prior exists, return placeholder.

   - **Do NOT import from environment.js** — this module is pure logic, no DOM/XLSX dependencies.

   After implementation, run the merge tests. All 11 should pass.
   Then run the existing 4 tests (`cd test && node run-tests.js`) to confirm no regressions.
  </action>
  <verify>
Run `cd C:/Users/amcallister/Projects/bom-tool/test && node merge-tests.js` — all 11 tests pass.
Run `cd C:/Users/amcallister/Projects/bom-tool/test && node run-tests.js` — all 4 existing tests pass (no regressions).
  </verify>
  <done>js/core/merge.js exports isReleased, buildPNIndex, and mergeBOM. All 11 merge tests pass. All 4 existing tests pass. Merge engine correctly detects WIP assemblies, grafts from B(n-1), handles REV0, creates placeholders, respects multi-branch independence, detects deep WIP, and tags every node with source.</done>
</task>

</tasks>

<verification>
1. `cd C:/Users/amcallister/Projects/bom-tool/test && node merge-tests.js` — 11/11 pass
2. `cd C:/Users/amcallister/Projects/bom-tool/test && node run-tests.js` — 4/4 pass (no regressions)
3. `js/core/merge.js` exports: isReleased, buildPNIndex, mergeBOM
4. Every node in merged output has `_source` property (`'current'` or `'grafted'`)
</verification>

<success_criteria>
- State whitelist correctly classifies IFP/IFU as Released, everything else as WIP
- Top-down walk stops at first WIP assembly on each branch and grafts from B(n-1)
- REV0 mode works when priorRoot is null — WIP assemblies become placeholders
- WIP assembly not found in B(n-1) becomes empty placeholder with warning
- Branches evaluated independently — WIP on one branch does not affect others
- Deep WIP detected and handled at L2, L3, and beyond
- Source tags present on every node in merged result
- Same WIP PN at multiple locations all get grafted
- All existing tests continue to pass
</success_criteria>

<output>
After completion, create `.planning/phases/11-core-merge-engine/11-01-SUMMARY.md`
</output>
