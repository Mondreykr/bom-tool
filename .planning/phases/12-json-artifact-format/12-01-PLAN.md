---
phase: 12-json-artifact-format
plan: 01
type: tdd
wave: 1
depends_on: []
files_modified:
  - js/core/artifact.js
  - test/artifact-tests.js
autonomous: true
must_haves:
  truths:
    - "Merged BOM tree serializes to JSON with all BOMNode fields preserved"
    - "JSON metadata includes SHA-256 integrity hash computed from BOM data"
    - "Merge summary stats (passedThrough, grafted, placeholders) are in the artifact"
    - "Source filenames (X(n) and B(n-1)) are stored in the artifact"
    - "Change annotations (_changes) on graft-point nodes are included"
    - "Source tags (_source) on all nodes are included"
    - "Filename follows pattern: {JOB_NUMBER}-IFP REV{n} (MMM D, YYYY).json"
    - "REV0 revision is fixed at 0; REV1+ auto-suggests B(n-1) revision + 1"
    - "Job number defaults to 1J + root PN for REV0, pulled from B(n-1) for REV1+"
  artifacts:
    - path: "js/core/artifact.js"
      provides: "JSON artifact export, hash computation, filename generation, revision logic"
      exports: ["exportArtifact", "computeHash", "generateFilename", "suggestRevision"]
    - path: "test/artifact-tests.js"
      provides: "TDD tests for ARTF-01, ARTF-02, ARTF-05, ARTF-06"
      min_lines: 200
  key_links:
    - from: "js/core/merge.js"
      to: "js/core/artifact.js"
      via: "mergeBOM output (mergedTree, warnings, summary) feeds exportArtifact"
      pattern: "mergedTree.*summary"
    - from: "js/core/artifact.js"
      to: "crypto.subtle.digest"
      via: "SHA-256 hash via Web Crypto API (browser) or Node crypto (test)"
      pattern: "SHA-256|sha256"
---

<objective>
Implement JSON artifact export for IFP BOMs: serialize the merged tree with all metadata, compute SHA-256 integrity hash, generate compliant filenames, and handle revision numbering.

Purpose: This is the data format that makes IFP artifacts portable, verifiable, and reimportable. The JSON file IS the official IFP BOM revision artifact — it must carry everything needed for the next merge cycle.

Output: `js/core/artifact.js` with export functions, `test/artifact-tests.js` with TDD tests covering ARTF-01, ARTF-02, ARTF-05, ARTF-06.
</objective>

<execution_context>
@C:/Users/amcallister/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/amcallister/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/12-json-artifact-format/12-CONTEXT.md
@.planning/phases/11-core-merge-engine/11-01-SUMMARY.md
@.planning/phases/11-core-merge-engine/11-02-SUMMARY.md
@js/core/merge.js
@js/core/tree.js
@test/merge-tests.js (first 60 lines — test helper patterns)
</context>

<tasks>

<task type="auto">
  <name>Task 1: RED — Write failing tests for artifact export, hash, filename, and revision</name>
  <files>test/artifact-tests.js</files>
  <action>
Create `test/artifact-tests.js` with the same test harness pattern used in `test/merge-tests.js` (import BOMNode from tree.js, use makeNode helper, console.log results, process.exit on failure).

Import from `../js/core/artifact.js`: `exportArtifact`, `computeHash`, `generateFilename`, `suggestRevision`.

Write these tests:

**Test 1: exportArtifact produces valid JSON structure (ARTF-01)**
- Create a simple merged tree (root with 2 children, one grafted, one current) using makeNode
- Call exportArtifact with the tree, metadata params (revision, jobNumber, sourceFilenames, summary)
- Assert the returned object has: `formatVersion`, `metadata` (with revision, jobNumber, generatedDate, hash, sourceFiles, summary), and `bom` (the tree)
- Assert the bom tree preserves all BOMNode fields: partNumber, componentType, description, material, qty, length, uofm, state, purchaseDescription, nsItemType, revision, children
- Assert `_source` tags are included on nodes
- Assert `_changes` arrays are included on graft-point nodes that have them

**Test 2: exportArtifact includes merge summary in metadata (ARTF-01)**
- Export an artifact with summary: {passedThrough: 5, grafted: 2, placeholders: 1}
- Assert metadata.summary matches exactly

**Test 3: exportArtifact includes source filenames in metadata (ARTF-01)**
- Export with sourceFiles: {xn: "258758-Rev4-20260211.XML", bn1: "1J258758-IFP REV3 (Feb 5, 2026).json"}
- Assert metadata.sourceFiles.xn and .bn1 match

**Test 4: exportArtifact includes _source tags and _changes (ARTF-01)**
- Create a tree where one node has `_source: 'grafted'` and `_changes: [{field:'qty', from:2, to:3}]`
- Export and assert both `_source` and `_changes` are in the serialized bom

**Test 5: computeHash returns SHA-256 hex string (ARTF-02)**
- Call computeHash on a known BOM tree
- Assert result is a 64-character hex string (SHA-256 = 256 bits = 64 hex chars)
- Assert result is deterministic (same tree = same hash)

**Test 6: computeHash detects BOM changes (ARTF-02)**
- Hash the same tree twice — assert identical
- Modify one field (e.g., change a qty) — assert different hash
- This proves the hash is sensitive to data changes

**Test 7: exportArtifact stores hash in metadata (ARTF-02)**
- Export an artifact
- Assert metadata.hash is a 64-char hex string
- Assert metadata.hash matches computeHash(bom)

**Test 8: generateFilename follows pattern (ARTF-05)**
- Call generateFilename("1J258758", 4) on a known date
- Assert result matches `1J258758-IFP REV4 (MMM D, YYYY).json` with correct date
- Note: test should mock or accept a date parameter to be deterministic

**Test 9: generateFilename handles REV0 (ARTF-05)**
- Call generateFilename("1J258758", 0)
- Assert result matches `1J258758-IFP REV0 (MMM D, YYYY).json`

**Test 10: suggestRevision returns 0 for REV0 mode (ARTF-06)**
- Call suggestRevision(null) (no B(n-1))
- Assert returns 0

**Test 11: suggestRevision returns B(n-1) revision + 1 (ARTF-06)**
- Call suggestRevision(priorArtifact) where priorArtifact.metadata.revision = 3
- Assert returns 4

**Test 12: suggestJobNumber returns "1J" + root PN for REV0 (ARTF-05/ARTF-06)**
- Call suggestJobNumber(null, "258758") (no B(n-1), root PN is "258758")
- Assert returns "1J258758"

**Test 13: suggestJobNumber returns B(n-1) jobNumber for REV1+ (ARTF-05/ARTF-06)**
- Call suggestJobNumber(priorArtifact, "258758") where priorArtifact.metadata.jobNumber = "1J258730"
- Assert returns "1J258730" (pulls from prior, even though root PN differs)

**Test 14: Round-trip: exported JSON can be parsed back to valid tree structure**
- Export an artifact, JSON.stringify it, JSON.parse it back
- Assert the bom tree structure is intact (children arrays, all fields present)
- This proves the format round-trips cleanly for reimport as B(n-1)

For SHA-256 in Node.js test environment, use `crypto.subtle.digest` (available in Node 15+) or `import { createHash } from 'crypto'` as a fallback. The implementation in artifact.js should use `crypto.subtle.digest` for browser compatibility, with an isomorphic approach similar to the existing `environment.js` pattern.

Run: `node test/artifact-tests.js`
All tests MUST FAIL (module not found or assertion failures). Commit: `test(12-01): add failing tests for artifact export, hash, filename, and revision`
  </action>
  <verify>Run `node test/artifact-tests.js` — all 14 tests should fail (import error or assertion failure). Zero tests should pass.</verify>
  <done>14 failing tests exist covering ARTF-01, ARTF-02, ARTF-05, ARTF-06. Tests are committed.</done>
</task>

<task type="auto">
  <name>Task 2: GREEN — Implement artifact.js to pass all tests</name>
  <files>js/core/artifact.js</files>
  <action>
Create `js/core/artifact.js` as a pure logic module (no DOM dependencies), following the same pattern as merge.js.

**Exports:**

1. `exportArtifact({ mergedTree, summary, revision, jobNumber, sourceFiles, date })` -> artifact object
   - `formatVersion`: "1.0" (for future-proofing)
   - `metadata`: { revision (number), jobNumber (string), generatedDate (ISO 8601), hash (string), sourceFiles: {xn, bn1}, summary: {passedThrough, grafted, placeholders} }
   - `bom`: the tree, serialized with ALL fields including `_source` and `_changes`
   - The tree serialization must recursively include: partNumber, componentType, description, material, qty, length, uofm, state, purchaseDescription, nsItemType, revision, children, _source, and _changes (if present)
   - Hash is computed from the `bom` portion only (not metadata), using `computeHash`
   - Per user decision: Exclude merge warnings from artifact (transient process artifacts)
   - Per user decision: Include `_source` tags on all nodes (needed for Phase 15 cross-tab display)
   - Per user decision: Include `_changes` on graft-point nodes (useful for artifact review)

2. `computeHash(bomTree)` -> 64-char hex string
   - Serialize the BOM tree to a canonical JSON string (sorted keys, deterministic)
   - Use `JSON.stringify` with a replacer that sorts keys alphabetically — this ensures identical trees always produce identical strings regardless of property insertion order
   - Compute SHA-256 of the canonical string
   - In browser: use `crypto.subtle.digest('SHA-256', ...)` (returns Promise, so computeHash is async)
   - In Node.js: use `import('crypto').then(c => c.createHash('sha256')...)` or `crypto.subtle` (Node 15+)
   - Return lowercase hex string
   - **IMPORTANT**: computeHash must be async (returns Promise) because Web Crypto API is async. exportArtifact is therefore also async.

3. `generateFilename(jobNumber, revision, date)` -> string
   - Pattern: `{jobNumber}-IFP REV{revision} ({MMM} {D}, {YYYY}).json`
   - `date` parameter defaults to new Date() — allows tests to pass a fixed date
   - Month format: abbreviated English (Jan, Feb, Mar, etc.)
   - Day format: no leading zero (1, 2, ... 31)
   - Example: `1J258758-IFP REV4 (Feb 11, 2026).json`

4. `suggestRevision(priorArtifact)` -> number
   - If priorArtifact is null/undefined: return 0 (REV0 mode)
   - If priorArtifact exists: return priorArtifact.metadata.revision + 1
   - Per user decision: REV0 is fixed at 0, no override; REV1+ can be overridden by user

5. `suggestJobNumber(priorArtifact, rootPartNumber)` -> string
   - If priorArtifact is null/undefined: return "1J" + rootPartNumber (REV0 default)
   - If priorArtifact exists: return priorArtifact.metadata.jobNumber
   - Per user decision: job number always starts with "1J"

**Canonical JSON for hashing:**
Write a `serializeBOM(node)` internal function that produces a deterministic object representation of the BOM tree. Use a replacer function in JSON.stringify that sorts object keys:
```javascript
function canonicalStringify(obj) {
    return JSON.stringify(obj, (key, value) => {
        if (value && typeof value === 'object' && !Array.isArray(value)) {
            return Object.keys(value).sort().reduce((sorted, k) => {
                sorted[k] = value[k];
                return sorted;
            }, {});
        }
        return value;
    });
}
```
This ensures the hash is deterministic regardless of JS engine property ordering.

**Tree serialization for the `bom` field:**
Write a `serializeNode(node)` internal function that produces a plain object from a BOMNode:
```javascript
function serializeNode(node) {
    const obj = {
        partNumber: node.partNumber,
        componentType: node.componentType,
        description: node.description,
        material: node.material,
        qty: node.qty,
        length: node.length,
        uofm: node.uofm,
        state: node.state,
        purchaseDescription: node.purchaseDescription,
        nsItemType: node.nsItemType,
        revision: node.revision,
        children: node.children.map(child => serializeNode(child))
    };
    // Include ephemeral tags for artifact storage
    if (node._source) obj._source = node._source;
    if (node._changes) obj._changes = node._changes;
    return obj;
}
```

Run: `node test/artifact-tests.js`
All 14 tests MUST PASS. Also run existing tests: `cd test && node run-tests.js` — 4 baseline + 19 merge tests must still pass.

Commit: `feat(12-01): implement artifact export with hash, filename, and revision`
  </action>
  <verify>Run `node test/artifact-tests.js` — all 14 tests pass. Run `cd C:/Users/amcallister/Projects/bom-tool/test && node run-tests.js` — all existing tests still pass. Run `cd C:/Users/amcallister/Projects/bom-tool/test && node merge-tests.js` — all 19 merge tests pass.</verify>
  <done>artifact.js exports all 5 functions, all 14 artifact tests pass, all 23 existing tests pass (no regressions), BOM tree round-trips cleanly through JSON serialization.</done>
</task>

</tasks>

<verification>
1. `node test/artifact-tests.js` — 14/14 pass
2. `cd test && node run-tests.js` — 4/4 baseline tests pass
3. `cd test && node merge-tests.js` — 19/19 merge tests pass
4. No new files modify existing modules (artifact.js is additive only)
</verification>

<success_criteria>
- exportArtifact produces JSON with formatVersion, metadata (revision, jobNumber, date, hash, sourceFiles, summary), and bom tree
- computeHash returns deterministic 64-char SHA-256 hex
- generateFilename follows `{JOB}-IFP REV{n} (MMM D, YYYY).json` pattern
- suggestRevision returns 0 for null, B(n-1).revision + 1 otherwise
- suggestJobNumber returns "1J" + rootPN for REV0, B(n-1).jobNumber for REV1+
- Tree serialization includes _source tags and _changes on all applicable nodes
- Round-trip: export -> JSON.stringify -> JSON.parse produces intact tree
</success_criteria>

<output>
After completion, create `.planning/phases/12-json-artifact-format/12-01-SUMMARY.md`
</output>
