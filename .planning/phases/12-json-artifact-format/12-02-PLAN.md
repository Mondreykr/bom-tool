---
phase: 12-json-artifact-format
plan: 02
type: tdd
wave: 2
depends_on: ["12-01"]
files_modified:
  - js/core/artifact.js
  - test/artifact-tests.js
autonomous: true
must_haves:
  truths:
    - "Importing a valid B(n-1) JSON file produces a usable BOMNode tree for merge"
    - "Importing a tampered JSON file shows a hash mismatch error with expected vs actual values"
    - "GA part number mismatch between X(n) and B(n-1) produces a warning with both values"
    - "Revision gap between B(n-1) and suggested revision produces a warning"
    - "Stale _changes from B(n-1) are stripped on import so they don't contaminate the next merge"
    - "Imported tree can be passed directly to mergeBOM as priorRoot"
  artifacts:
    - path: "js/core/artifact.js"
      provides: "importArtifact and validateArtifact added to existing module"
      exports: ["exportArtifact", "computeHash", "generateFilename", "suggestRevision", "suggestJobNumber", "importArtifact", "validateArtifact"]
    - path: "test/artifact-tests.js"
      provides: "Additional TDD tests for ARTF-03 and ARTF-04"
      min_lines: 400
  key_links:
    - from: "js/core/artifact.js importArtifact"
      to: "js/core/merge.js mergeBOM"
      via: "importArtifact returns tree usable as priorRoot in mergeBOM"
      pattern: "importArtifact.*priorRoot"
    - from: "js/core/artifact.js validateArtifact"
      to: "js/core/artifact.js computeHash"
      via: "validateArtifact recomputes hash and compares to stored hash"
      pattern: "computeHash.*metadata\\.hash"
---

<objective>
Implement JSON artifact import and validation: parse B(n-1) JSON files, verify SHA-256 hash integrity, validate GA part number match, detect revision gaps, and strip stale merge annotations.

Purpose: This completes the artifact round-trip. Import validation ensures B(n-1) files haven't been tampered with and belong to the correct assembly, which is critical for production BOM integrity.

Output: `importArtifact` and `validateArtifact` functions added to `js/core/artifact.js`, additional tests in `test/artifact-tests.js` covering ARTF-03 and ARTF-04.
</objective>

<execution_context>
@C:/Users/amcallister/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/amcallister/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/12-json-artifact-format/12-CONTEXT.md
@.planning/phases/12-json-artifact-format/12-01-SUMMARY.md
@js/core/artifact.js
@js/core/merge.js
@js/core/tree.js
</context>

<tasks>

<task type="auto">
  <name>Task 1: RED — Write failing tests for artifact import and validation</name>
  <files>test/artifact-tests.js</files>
  <action>
Add tests to the existing `test/artifact-tests.js` file (append after plan 01 tests). Import `importArtifact` and `validateArtifact` from `../js/core/artifact.js`.

**Test 15: importArtifact parses JSON string to artifact object**
- Take the output of exportArtifact, JSON.stringify it, then call importArtifact(jsonString)
- Assert it returns an object with formatVersion, metadata, and bom
- Assert the bom tree has correct structure (root with children)

**Test 16: importArtifact reconstructs tree with all BOMNode fields**
- Import a JSON artifact string
- Walk the bom tree and verify every node has: partNumber, componentType, description, material, qty, length, uofm, state, purchaseDescription, nsItemType, revision, children
- Assert children arrays are proper arrays (not undefined)

**Test 17: importArtifact strips stale _changes from B(n-1) nodes**
- Create an artifact where some nodes have `_changes` arrays (from a previous merge)
- Export it, stringify it, import it
- Assert that `_changes` arrays are removed from imported bom nodes
- Rationale: _changes are specific to the merge that created THIS artifact; when this artifact becomes B(n-1) for the NEXT merge, those old changes are irrelevant and would be confusing

**Test 18: importArtifact preserves _source tags**
- Import an artifact where nodes have _source tags
- Assert _source tags are preserved (they indicate whether content was current or grafted in the artifact's creation, useful for cross-tab display)

**Test 19: validateArtifact passes for unmodified artifact (ARTF-03)**
- Export an artifact, stringify it, import it
- Call validateArtifact(artifact) — assert it returns { valid: true, errors: [], warnings: [] }

**Test 20: validateArtifact detects hash mismatch (ARTF-03)**
- Export an artifact, stringify it, parse it, manually modify a node's qty in the bom
- Call validateArtifact(modifiedArtifact)
- Assert valid: false
- Assert errors array contains a message with BOTH expected and actual hash values
- Per user decision: detailed error messages showing "Hash mismatch: expected {X}, computed {Y}"

**Test 21: validateArtifact detects hash mismatch from added node (ARTF-03)**
- Export an artifact, add a child node to the bom tree
- Validate — assert valid: false with hash mismatch error

**Test 22: validateArtifact validates GA part number match (ARTF-04)**
- Create a prior artifact where root PN is "258758"
- Call validateArtifact(artifact, { expectedGA: "258758" }) — assert valid: true, no warnings about GA mismatch

**Test 23: validateArtifact warns on GA part number mismatch (ARTF-04)**
- Create a prior artifact where root PN is "258758"
- Call validateArtifact(artifact, { expectedGA: "258730" })
- Assert valid: true (per user decision: warn but allow override)
- Assert warnings array contains message showing both PNs: "GA mismatch: X(n) root is 258730, B(n-1) root is 258758"

**Test 24: validateArtifact warns on revision gap (ARTF-06 related)**
- Create a prior artifact with revision 2
- Call validateArtifact(artifact, { expectedRevision: 5 })
- Assert valid: true (per user decision: warn about non-sequential, but allow)
- Assert warnings array mentions the gap

**Test 25: validateArtifact passes for sequential revision (no gap warning)**
- Prior artifact with revision 2, expectedRevision: 3
- Assert valid: true, no revision-related warnings

**Test 26: importArtifact output is usable as priorRoot in mergeBOM**
- Export an artifact from a merged tree
- Stringify, import the artifact
- Create a new source tree (X(n)) with a WIP assembly matching one in the imported bom
- Call mergeBOM(newSourceRoot, importedArtifact.bom) — assert it works without errors
- Assert the grafted node comes from the imported B(n-1) content
- This is the critical round-trip test: export -> import -> merge

Run: `node test/artifact-tests.js`
New tests MUST FAIL. Commit: `test(12-02): add failing tests for artifact import and validation`
  </action>
  <verify>Run `node test/artifact-tests.js` — tests 1-14 (from plan 01) pass, tests 15-26 fail. Plan 01 tests must not regress.</verify>
  <done>12 new failing tests (15-26) covering ARTF-03, ARTF-04, round-trip, and edge cases. All plan 01 tests still pass.</done>
</task>

<task type="auto">
  <name>Task 2: GREEN — Implement importArtifact and validateArtifact</name>
  <files>js/core/artifact.js</files>
  <action>
Add two new exported functions to `js/core/artifact.js`:

1. `importArtifact(jsonString)` -> artifact object
   - Parse JSON string via JSON.parse
   - Validate basic structure: must have formatVersion, metadata, bom
   - Walk the bom tree and strip `_changes` arrays from all nodes (stale from prior merge — per Claude's Discretion, these are specific to the merge that created this artifact and would be misleading in the next merge)
   - Preserve `_source` tags (useful for cross-tab display)
   - Ensure all children arrays exist (replace undefined with empty array)
   - Return the parsed artifact object: { formatVersion, metadata, bom }
   - The bom tree should be directly usable as `priorRoot` in mergeBOM()

   Internal helper `stripStaleAnnotations(node)`:
   ```javascript
   function stripStaleAnnotations(node) {
       delete node._changes;  // Stale from prior merge
       if (node.children) {
           node.children.forEach(child => stripStaleAnnotations(child));
       }
   }
   ```

2. `validateArtifact(artifact, options)` -> { valid: boolean, errors: string[], warnings: string[] }
   - `artifact`: parsed artifact object (from importArtifact)
   - `options` (optional): { expectedGA: string, expectedRevision: number }
   - Returns { valid, errors, warnings }

   **Hash verification (ARTF-03):**
   - Recompute hash from artifact.bom using computeHash()
   - Compare to artifact.metadata.hash
   - If mismatch: valid = false, push to errors: `"Integrity check failed: stored hash ${stored}, computed hash ${computed}"`
   - Per Claude's Discretion on strictness: **hard block** — hash mismatch means the file was modified outside the tool, and using it risks producing an incorrect B(n). Errors are blocking; only warnings are overridable.

   **GA part number validation (ARTF-04):**
   - If options.expectedGA provided: compare to artifact.bom.partNumber (root PN of B(n-1))
   - If mismatch: valid stays true (warning, not error), push to warnings: `"GA part number mismatch: X(n) root is ${expected}, B(n-1) root is ${actual}"`
   - Per user decision: warn but allow override

   **Revision gap detection:**
   - If options.expectedRevision provided: check if expectedRevision = artifact.metadata.revision + 1
   - If gap exists (expectedRevision > artifact.metadata.revision + 1): push to warnings: `"Revision gap: B(n-1) is REV${prior}, next would be REV${prior+1}, but REV${expected} was specified"`
   - Per user decision: warn but allow

   **Return value:**
   - valid: true UNLESS hash mismatch (only errors make valid=false)
   - errors: blocking issues (hash mismatch)
   - warnings: non-blocking issues (GA mismatch, revision gap)

   Note: validateArtifact must be async because computeHash is async.

Run: `node test/artifact-tests.js`
All 26 tests MUST PASS. Also run existing tests: `cd test && node run-tests.js` and `cd test && node merge-tests.js` — all must pass.

Commit: `feat(12-02): implement artifact import and validation`
  </action>
  <verify>Run `node test/artifact-tests.js` — all 26 tests pass. Run `cd C:/Users/amcallister/Projects/bom-tool/test && node run-tests.js` — all 4 baseline tests pass. Run `cd C:/Users/amcallister/Projects/bom-tool/test && node merge-tests.js` — all 19 merge tests pass.</verify>
  <done>importArtifact parses JSON and strips stale _changes, validateArtifact verifies hash (hard block) and GA PN (warning), all 26 artifact tests pass, all 23 prior tests pass, round-trip from export to import to merge works.</done>
</task>

</tasks>

<verification>
1. `node test/artifact-tests.js` — 26/26 pass
2. `cd test && node run-tests.js` — 4/4 baseline tests pass
3. `cd test && node merge-tests.js` — 19/19 merge tests pass
4. Round-trip verified: exportArtifact -> JSON.stringify -> importArtifact -> mergeBOM works
5. Hash mismatch blocks import (valid: false with detailed error)
6. GA mismatch warns but allows (valid: true with warning)
</verification>

<success_criteria>
- importArtifact parses JSON string to usable artifact with intact bom tree
- importArtifact strips _changes (stale from prior merge) but preserves _source
- validateArtifact blocks on hash mismatch with expected vs actual in error message
- validateArtifact warns (not blocks) on GA part number mismatch
- validateArtifact warns on non-sequential revision numbers
- Imported bom tree works directly as priorRoot in mergeBOM (round-trip proven)
- All 26 artifact tests + 23 prior tests pass (49 total)
</success_criteria>

<output>
After completion, create `.planning/phases/12-json-artifact-format/12-02-SUMMARY.md`
</output>
