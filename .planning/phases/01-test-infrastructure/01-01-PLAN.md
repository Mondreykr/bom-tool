---
phase: 01-test-infrastructure
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - js/core/environment.js
  - js/core/utils.js
  - js/core/tree.js
  - js/core/flatten.js
  - js/core/parser.js
  - js/core/compare.js
autonomous: true

must_haves:
  truths:
    - "Core BOM functions exist as ES6 modules with named exports"
    - "Environment abstraction detects Node.js and provides DOMParser from xmldom"
    - "Module files contain the exact same logic as the copied functions in test/run-tests.js lines 22-462"
    - "No circular dependencies between modules"
  artifacts:
    - path: "js/core/environment.js"
      provides: "Runtime detection, DOMParser abstraction, XLSX abstraction"
      exports: ["isBrowser", "isNode", "DOMParser", "XLSX"]
    - path: "js/core/utils.js"
      provides: "Zero-dependency utility functions"
      exports: ["parseLength", "decimalToFractional", "getParentLevel", "getCompositeKey"]
    - path: "js/core/tree.js"
      provides: "BOMNode class and tree construction"
      exports: ["BOMNode", "buildTree"]
    - path: "js/core/flatten.js"
      provides: "BOM flattening and sorting"
      exports: ["flattenBOM", "sortBOM"]
    - path: "js/core/parser.js"
      provides: "XML and CSV file parsing"
      exports: ["parseXML", "parseCSV"]
    - path: "js/core/compare.js"
      provides: "BOM comparison and subtree operations"
      exports: ["compareBOMs", "findNodeByPartNumber", "extractSubtree"]
  key_links:
    - from: "js/core/tree.js"
      to: "js/core/utils.js"
      via: "import { parseLength, getParentLevel } from './utils.js'"
      pattern: "import.*from.*utils\\.js"
    - from: "js/core/flatten.js"
      to: "js/core/utils.js"
      via: "import { getCompositeKey, decimalToFractional } from './utils.js'"
      pattern: "import.*from.*utils\\.js"
    - from: "js/core/parser.js"
      to: "js/core/environment.js"
      via: "import { DOMParser, XLSX } from './environment.js'"
      pattern: "import.*from.*environment\\.js"
    - from: "js/core/parser.js"
      to: "js/core/tree.js"
      via: "import { BOMNode } from './tree.js'"
      pattern: "import.*BOMNode.*from.*tree\\.js"
    - from: "js/core/compare.js"
      to: "js/core/tree.js"
      via: "import { BOMNode } from './tree.js'"
      pattern: "import.*BOMNode.*from.*tree\\.js"
---

<objective>
Extract the core BOM processing functions from copied code in the test harness into proper ES6 module files under `js/core/`. These modules become the single source of truth for all business logic, used by both the test harness (Node.js) and eventually the browser application.

Purpose: Create the module files that the test harness will import from, eliminating the ~430 lines of duplicated production code in `test/run-tests.js`. This is the foundation for all subsequent refactoring phases.

Output: Six ES6 module files in `js/core/` with named exports matching the exact function signatures and behavior of the copied functions currently in `test/run-tests.js`.
</objective>

<execution_context>
@C:\Users\amcallister\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\amcallister\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01-test-infrastructure/01-CONTEXT.md
@.planning/phases/01-test-infrastructure/01-RESEARCH.md
@test/run-tests.js
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create environment abstraction and utility modules</name>
  <files>js/core/environment.js, js/core/utils.js</files>
  <action>
Create the `js/core/` directory structure. Then create two leaf-level modules (no internal dependencies):

**js/core/environment.js** - Runtime environment detection and platform-specific dependency loading:
- Export `isBrowser` constant: `typeof window !== 'undefined'`
- Export `isNode` constant: `typeof process !== 'undefined' && process.versions?.node`
- Export `DOMParser`: In Node.js, dynamically import from 'xmldom' package. In browser, use `window.DOMParser`.
- Export `XLSX`: In Node.js, dynamically import from 'xlsx' package and call `XLSX.set_fs(fs)`. In browser, use `window.XLSX`.
- Use top-level `await` for dynamic imports (supported in ES modules).
- Include validation: throw helpful error if browser XLSX is undefined.

**js/core/utils.js** - Zero-dependency utility functions (no imports from other js/core/ files):
- Export `parseLength(lengthStr)` - copied exactly from test/run-tests.js lines 28-39
- Export `decimalToFractional(decimal)` - copied exactly from test/run-tests.js lines 112-137
- Export `getParentLevel(level)` - copied exactly from test/run-tests.js lines 42-45
- Export `getCompositeKey(partNumber, length)` - copied exactly from test/run-tests.js lines 104-109

CRITICAL: Copy function bodies EXACTLY from test/run-tests.js. Do not optimize, refactor, or "improve" any logic. The zero-tolerance requirement means identical behavior.
  </action>
  <verify>
Verify both files exist, have correct exports, and contain no syntax errors:
```bash
node -e "import('./js/core/environment.js').then(m => { console.log('environment.js exports:', Object.keys(m)); console.log('isNode:', m.isNode); })"
node -e "import('./js/core/utils.js').then(m => { console.log('utils.js exports:', Object.keys(m)); console.log('parseLength test:', m.parseLength('17.063')); console.log('fractional test:', m.decimalToFractional(17.063)); console.log('parentLevel test:', m.getParentLevel('1.1.1')); console.log('compositeKey test:', m.getCompositeKey('PART1', 17.063)); })"
```
Expected: environment.js exports isBrowser, isNode, DOMParser, XLSX. Utils functions return correct values.
  </verify>
  <done>environment.js and utils.js exist in js/core/ with all named exports. Quick smoke test shows functions return expected values.</done>
</task>

<task type="auto">
  <name>Task 2: Create tree, flatten, parser, and compare modules</name>
  <files>js/core/tree.js, js/core/flatten.js, js/core/parser.js, js/core/compare.js</files>
  <action>
Create four modules that import from environment.js and utils.js:

**js/core/tree.js** - BOMNode class and tree construction:
- `import { parseLength, getParentLevel } from './utils.js';`
- Export `BOMNode` class - copied exactly from test/run-tests.js lines 49-65. Note: constructor calls `parseLength()` for the length field.
- Export `buildTree(rows)` function - copied exactly from test/run-tests.js lines 68-101.
- IMPORTANT: `buildTree()` currently sets global variables `rootPartNumber`, `rootRevision`, `rootDescription`. For now, keep these as module-level variables AND also return them. Specifically: declare the three variables at module scope, set them in buildTree(), and also return `{ tree: root, rootPartNumber, rootRevision, rootDescription }` from buildTree(). This way the test harness can access them without globals. BUT ALSO keep the original return signature working - return just `root` from buildTree() for backward compatibility. Solution: have buildTree() set module-level variables AND return just root (same as current behavior). Export getter functions `getRootPartNumber()`, `getRootRevision()`, `getRootDescription()` for code that needs them.

**js/core/flatten.js** - BOM flattening and sorting:
- `import { getCompositeKey, decimalToFractional } from './utils.js';`
- Export `flattenBOM(rootNode, unitQty)` - copied exactly from test/run-tests.js lines 140-185. Note: calls getCompositeKey() and decimalToFractional() from utils.
- Export `sortBOM(items)` - copied exactly from test/run-tests.js lines 188-209.

**js/core/parser.js** - XML and CSV parsing:
- `import { DOMParser, XLSX, isNode } from './environment.js';`
- Export `parseXML(xmlText)` - copied exactly from test/run-tests.js lines 212-303. Replace the direct `new DOMParser()` with the imported DOMParser.
- Export `parseCSV(csvTextOrPath)` - Adapted from test/run-tests.js lines 306-339. In Node.js mode, if argument looks like a file path, read it from disk. In browser mode, expect text content directly. The current test version always reads from file path. The function should handle both: if isNode and argument contains path separator, read from disk; otherwise treat as text content.
- IMPORTANT: parseCSV uses `fs.readFileSync` and `XLSX` directly. In the module version, import fs conditionally (only in Node.js) and use the XLSX from environment.js.

**js/core/compare.js** - BOM comparison and subtree operations:
- `import { getCompositeKey } from './utils.js';`
- `import { BOMNode } from './tree.js';`
- `import { parseLength } from './utils.js';`
- Export `compareBOMs(oldFlattened, newFlattened)` - copied exactly from test/run-tests.js lines 346-427.
- Export `findNodeByPartNumber(node, targetPartNumber)` - copied exactly from test/run-tests.js lines 430-439.
- Export `extractSubtree(node)` - copied exactly from test/run-tests.js lines 442-462. Note: creates new BOMNode instances, so needs the BOMNode import.

CRITICAL: Copy all function bodies EXACTLY. Do not change any logic, conditionals, or string handling. The only changes allowed are: (1) adding import statements, (2) adding export keywords, (3) replacing direct `new DOMParser()` with the imported abstraction, (4) replacing direct `fs`/`XLSX` references with imported abstractions.
  </action>
  <verify>
Verify all four modules load correctly in Node.js:
```bash
node -e "
import { BOMNode, buildTree } from './js/core/tree.js';
import { flattenBOM, sortBOM } from './js/core/flatten.js';
import { parseXML, parseCSV } from './js/core/parser.js';
import { compareBOMs, findNodeByPartNumber, extractSubtree } from './js/core/compare.js';
console.log('All modules imported successfully');
console.log('BOMNode:', typeof BOMNode);
console.log('buildTree:', typeof buildTree);
console.log('flattenBOM:', typeof flattenBOM);
console.log('sortBOM:', typeof sortBOM);
console.log('parseXML:', typeof parseXML);
console.log('parseCSV:', typeof parseCSV);
console.log('compareBOMs:', typeof compareBOMs);
console.log('findNodeByPartNumber:', typeof findNodeByPartNumber);
console.log('extractSubtree:', typeof extractSubtree);
"
```
Expected: All imports resolve, all exports are functions (BOMNode is function/class).
  </verify>
  <done>All four module files exist in js/core/ with correct imports and exports. All modules load without errors in Node.js. No circular dependencies.</done>
</task>

<task type="auto">
  <name>Task 3: Quick integration smoke test of extracted modules</name>
  <files>(no new files - tests existing modules)</files>
  <action>
Run a quick integration test to verify the extracted modules can actually process a test file end-to-end. This catches any subtle extraction errors before Plan 02 rewires the full test harness.

Execute this one-shot Node.js script from the project root:
```bash
node -e "
import fs from 'fs';
import { parseXML } from './js/core/parser.js';
import { buildTree } from './js/core/tree.js';
import { flattenBOM, sortBOM } from './js/core/flatten.js';

const xmlText = fs.readFileSync('./test-data/258730-Rev2-20260105.XML', 'utf8');
const rows = parseXML(xmlText);
console.log('Parsed rows:', rows.length);

const root = buildTree(rows);
console.log('Root part:', root.partNumber);

const flattened = flattenBOM(root, 1);
const sorted = sortBOM(flattened);
console.log('Flattened items:', sorted.length);
console.log('Expected: 201 items');
console.log(sorted.length === 201 ? 'PASS' : 'FAIL - count mismatch');
"
```

If the count does not match 201, investigate and fix the extraction error in the relevant module file. The 201 count is confirmed from the current test run output.

Also test the comparison pipeline:
```bash
node -e "
import fs from 'fs';
import { parseXML } from './js/core/parser.js';
import { buildTree } from './js/core/tree.js';
import { flattenBOM } from './js/core/flatten.js';
import { compareBOMs } from './js/core/compare.js';

const oldXml = fs.readFileSync('./test-data/258754-Rev0-20251220.XML', 'utf8');
const newXml = fs.readFileSync('./test-data/258754-Rev1-20260112.XML', 'utf8');

const oldRows = parseXML(oldXml);
const oldTree = buildTree(oldRows);
const oldFlat = flattenBOM(oldTree, 1);

const newRows = parseXML(newXml);
const newTree = buildTree(newRows);
const newFlat = flattenBOM(newTree, 1);

const results = compareBOMs(oldFlat, newFlat);
console.log('Comparison results:', results.length);
console.log('Expected: 41 changes');
console.log(results.length === 41 ? 'PASS' : 'FAIL - count mismatch');
"
```

Both tests must output PASS. If either fails, fix the module extraction error before completing this task.
  </action>
  <verify>Both quick smoke tests output PASS with correct item counts (201 flat items, 41 comparison changes).</verify>
  <done>Extracted modules produce identical outputs to the copied functions for both flat BOM and comparison pipelines.</done>
</task>

</tasks>

<verification>
After all tasks complete:
1. `js/core/` directory exists with 6 files: environment.js, utils.js, tree.js, flatten.js, parser.js, compare.js
2. All modules import cleanly in Node.js (no missing dependencies, no circular imports)
3. Quick smoke tests confirm flat BOM produces 201 items and comparison produces 41 changes
4. No modifications made to index.html or test/run-tests.js (those happen in Plan 02)
</verification>

<success_criteria>
- Six ES6 module files exist in js/core/ with correct named exports
- Modules use environment abstraction for DOMParser and XLSX (cross-environment compatible)
- All .js extensions present in import paths
- Quick integration smoke tests pass (201 flat items, 41 comparison changes)
- Zero logic changes from the copied functions in test/run-tests.js
</success_criteria>

<output>
After completion, create `.planning/phases/01-test-infrastructure/01-01-SUMMARY.md`
</output>
